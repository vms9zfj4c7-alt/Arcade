<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Arcade Ultimate - Mobile Edition (V7)</title>
    <style>
        /* --- DESIGN GLOBAL --- */
        :root {
            --bg-color: #0a0a12;
            --panel-bg: #16213e;
            --text-color: #ecf0f1;
            --accent-gold: #f1c40f;
            --vault-color: #2c3e50;
            --tron-cyan: #00fff2;
            --tron-orange: #ff6b6b;
            --flappy-yellow: #f1c40f;
            --flappy-green: #2ecc71;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            width: 100%;
            user-select: none;
            overflow-x: hidden;
            touch-action: none; /* Emp√™che le scroll pendant le jeu */
            -webkit-tap-highlight-color: transparent;
        }

        h1 { text-align: center; margin-bottom: 20px; letter-spacing: 2px; text-shadow: 0 0 10px rgba(241, 196, 15, 0.5); font-size: 2rem; }
        h2 { color: var(--accent-gold); text-transform: uppercase; margin-bottom: 15px; border-bottom: 2px solid var(--accent-gold); display: inline-block; padding-bottom: 5px; font-size: 1.5rem; }
        h3 { border-bottom: 1px solid #7f8c8d; padding-bottom: 5px; margin-top: 20px; font-size: 16px; color: #3498db; }

        /* MENUS RESPONSIVE */
        .game-menu-card {
            background-color: var(--panel-bg);
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 2px solid #30475e;
            text-align: center;
            width: 90%; /* Largeur relative */
            max-width: 500px; /* Max pour PC */
            animation: fadeIn 0.5s ease-out;
            margin: 60px auto 20px auto;
            box-sizing: border-box;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }

        button {
            border: none; color: white; padding: 15px 25px; border-radius: 8px; font-size: 18px; cursor: pointer;
            transition: all 0.2s; font-weight: bold; box-shadow: 0 4px 6px rgba(0,0,0,0.3); position: relative; overflow: hidden;
            margin: 5px 0; touch-action: manipulation;
        }
        button:hover { transform: translateY(-3px); box-shadow: 0 7px 15px rgba(0,0,0,0.4); filter: brightness(1.1); }
        button:active { transform: translateY(1px); }

        /* BOUTON RETOUR (FIXE) */
        .back-to-hub { 
            background-color: #7f8c8d; 
            padding: 8px 15px; 
            font-size: 14px;
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 9999;
            box-shadow: 0 0 10px rgba(0,0,0,0.8);
            border: 1px solid #fff;
            border-radius: 20px;
        }

        /* HUB */
        #mainHub { position: relative; border: 2px solid var(--accent-gold); margin-top: 20px; }
        #vaultBtn { position: absolute; top: 15px; right: 15px; background: none; font-size: 24px; padding: 0; cursor: pointer; opacity: 0.6; transition: opacity 0.3s; box-shadow: none; }
        #vaultBtn:hover { opacity: 1; transform: scale(1.2); }

        /* COFFRE FORT */
        #vaultOverlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; align-items: center; justify-content: center; backdrop-filter: blur(5px); }
        #vaultContent { background-color: var(--vault-color); padding: 20px; border-radius: 15px; width: 90%; max-width: 400px; border: 2px solid var(--accent-gold); box-shadow: 0 0 30px rgba(241, 196, 15, 0.3); text-align: center; max-height: 85vh; overflow-y: auto; }
        
        #vaultAuth input { font-size: 24px; text-align: center; letter-spacing: 5px; width: 80%; padding: 10px; margin: 15px 0; border-radius: 5px; border: none; background: #ecf0f1; color: #2c3e50;}
        #vaultError { color: #e74c3c; font-weight: bold; display: none; margin-bottom: 10px; animation: shake 0.3s; }
        @keyframes shake { 0% { transform: translateX(0); } 25% { transform: translateX(-10px); } 50% { transform: translateX(10px); } 75% { transform: translateX(-10px); } 100% { transform: translateX(0); } }

        #vaultSettings { display: none; text-align: left; }
        .vault-group { margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; }
        .vault-group label { font-size: 14px; color: #bdc3c7; flex: 1; }
        .vault-group input, .vault-group select { width: 80px; padding: 8px; border-radius: 5px; border: none; background: #ecf0f1; color: #2c3e50; font-weight: bold; font-size: 16px; }

        /* BOUTONS HUB */
        .btn-hub { width: 100%; max-width: 320px; display: block; margin: 12px auto; font-size: 18px; padding: 15px; text-align: left; padding-left: 20px; box-sizing: border-box; }
        .btn-snake-hub { background: linear-gradient(45deg, #8e44ad, #9b59b6); }
        .btn-mine-hub { background: linear-gradient(45deg, #2980b9, #3498db); }
        .btn-ttt-hub { background: linear-gradient(45deg, #c0392b, #e74c3c); }
        .btn-c4-hub { background: linear-gradient(45deg, #d35400, #e67e22); }
        .btn-tetris-hub { background: linear-gradient(45deg, #16a085, #1abc9c); }
        .btn-pong-hub { background: linear-gradient(45deg, #e17055, #d63031); }
        .btn-tron-hub { background: linear-gradient(45deg, #00cec9, #00fff2); box-shadow: 0 0 15px rgba(0, 255, 242, 0.4); } 
        .btn-mm-hub { background: linear-gradient(45deg, #fd79a8, #e84393); } 
        .btn-flappy-hub { background: linear-gradient(45deg, #f1c40f, #e67e22); box-shadow: 0 0 15px rgba(241, 196, 15, 0.3); }
        .btn-custom { background-color: #8e44ad; border: 1px dashed var(--accent-gold); color: var(--accent-gold); width: 100%; } 

        .level-btn { display: block; width: 100%; margin: 10px 0; padding: 15px; font-size: 18px; }
        .btn-pvp { background-color: #3498db; }
        .btn-easy { background-color: #2ecc71; }
        .btn-medium { background-color: #f39c12; }
        .btn-hard { background-color: #e74c3c; }

        /* CONTAINERS JEUX */
        #snakeRoot, #minesweeperRoot, #tictactoeRoot, #connect4Root, #tetrisRoot, #pongRoot, #tronRoot, #mmRoot, #flappyRoot { 
            display: none; 
            flex-direction: column; 
            align-items: center;
            justify-content: flex-start; /* Chang√© pour mobile */
            width: 100%; 
            min-height: 100vh;
            position: absolute;
            top: 0; left: 0;
            background-color: var(--bg-color);
            padding-top: 60px;
            padding-bottom: 150px; /* Espace pour les contr√¥les */
            box-sizing: border-box;
            overflow-y: auto;
        }
        
        /* GENERAL CANVAS/GRID - RESPONSIVE */
        canvas { 
            background-color: #000; 
            border: 2px solid #ecf0f1; 
            box-shadow: 0 0 20px rgba(0,0,0,0.5); 
            display: none; 
            border-radius: 4px; 
            margin: 0 auto; 
            /* Responsive Magic */
            max-width: 95vw; 
            max-height: 70vh;
            height: auto;
            width: auto;
            object-fit: contain;
        }

        .checkbox-container { display: block; margin-bottom: 20px; font-size: 18px; cursor: pointer; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1); width: 100%; box-sizing: border-box; }
        input[type=checkbox] { transform: scale(1.5); margin-right: 15px; accent-color: var(--accent-gold); }
        
        /* HEADER SCORE */
        .header-mine { display: flex; justify-content: space-between; width: 95%; max-width: 400px; background: var(--panel-bg); padding: 10px 20px; border-radius: 10px; margin-bottom: 15px; box-sizing: border-box; border: 1px solid #34495e;}
        .score-board-common { display: flex; gap: 10px; margin-bottom: 15px; font-size: 18px; font-weight: bold; justify-content: center; flex-wrap: wrap; }
        .score-box { padding: 10px 15px; background: #16213e; border-radius: 8px; border: 1px solid #30475e; min-width: 60px; text-align: center; }
        .p1-score { color: #e74c3c; border-bottom: 3px solid #e74c3c; } .p2-score { color: #3498db; border-bottom: 3px solid #3498db; } .p2-score-c4 { color: #f1c40f; border-bottom: 3px solid #f1c40f; }

        /* GRIDS & CELLS */
        #grid, .dynamic-grid { display: grid; gap: 2px; background-color: var(--panel-bg); padding: 5px; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); position: relative; margin: 0 auto; }
        .cell, .ttt-cell, .c4-cell { display: flex; align-items: center; justify-content: center; font-weight: bold; cursor: pointer; transition: transform 0.2s; }
        
        /* Mine */
        .cell { width: 30px; height: 30px; background-color: #0f3460; border-radius: 3px; font-size: 18px; }
        .cell:hover { background-color: #1f4287; } .cell.revealed { background-color: #2c2c54; cursor: default; } .cell.bomb { background-color: #e94560; } .cell.flag { color: #f1c40f; }
        .c1 { color: #3498db; } .c2 { color: #2ecc71; } .c3 { color: #e74c3c; }
        
        /* TTT */
        .dynamic-grid { gap: 5px; background-color: #30475e; }
        .ttt-cell { background-color: var(--panel-bg); font-size: 2em; color: white; width: 60px; height: 60px; }
        .ttt-cell:hover { background-color: #2c3e50; } .ttt-cell.x { color: #e74c3c; } .ttt-cell.o { color: #3498db; }
        
        /* Connect 4 */
        #c4Grid { background-color: #0984e3; gap: 5px; }
        .c4-cell { background-color: var(--bg-color); border-radius: 50%; box-shadow: inset 0 0 10px rgba(0,0,0,0.5); width: 40px; height: 40px;}
        .c4-cell.red { background-color: #e74c3c; } .c4-cell.yellow { background-color: #f1c40f; }
        
        .disappear { transform: scale(0); opacity: 0; }
        .winning-line { position: absolute; background-color: white; border-radius: 5px; transform-origin: left center; z-index: 20; display: none; box-shadow: 0 0 10px white; pointer-events: none; }

        /* TETRIS UI */
        #tetrisGameContainer { display: none; flex-direction: column; gap: 10px; align-items: center; justify-content: center; }
        #tetrisBoard { border: 4px solid #16a085; display: block; box-shadow: 0 0 20px rgba(22, 160, 133, 0.4); max-height: 60vh; }
        .tetris-ui { display: flex; flex-direction: row; gap: 10px; width: 100%; justify-content: center; }
        .tetris-panel { background-color: var(--panel-bg); border: 2px solid #16a085; border-radius: 10px; padding: 5px; text-align: center; width: 80px; }
        .tetris-panel h4 { margin: 0 0 5px 0; color: #1abc9c; font-size: 12px; }
        #nextPieceCanvas { background-color: #000; border: 1px solid #34495e; margin: 0 auto; display: block; width: 60px; height: 60px;}
        #tetrisScoreVal { font-size: 18px; font-weight: bold; color: white; }

        /* PONG UI */
        #pongGameContainer { display: none; flex-direction: column; align-items: center; width: 100%; }
        #pongCanvas { border: 2px solid #e17055; cursor: none; width: 95%; height: auto; aspect-ratio: 7/5; } 
        #pongScoreBoard { font-family: 'Courier New', monospace; font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #e17055; letter-spacing: 5px; }

        /* TRON UI */
        #tronGameContainer { display: none; flex-direction: column; align-items: center; width: 100%; }
        #tronCanvas { border: 2px solid var(--tron-cyan); box-shadow: 0 0 15px rgba(0, 255, 242, 0.3); background-color: #000; width: 95%; height: auto; aspect-ratio: 3/2; }
        .tron-score { color: var(--tron-cyan); font-family: 'Courier New', monospace; font-size: 18px; font-weight: bold; margin-bottom: 10px; text-shadow: 0 0 10px var(--tron-cyan); }
        .p1-tron { color: var(--tron-cyan); } 
        .p2-tron { color: var(--tron-orange); } 

        /* FLAPPY UI */
        #flappyGameContainer { display: none; flex-direction: column; align-items: center; position: relative; width: 100%; }
        #flappyCanvas { border: 4px solid var(--flappy-green); background-color: #000; width: 90%; max-width: 400px; height: auto; aspect-ratio: 2/3; }
        #flappyScoreBoard { font-family: 'Courier New', monospace; font-size: 30px; font-weight: bold; margin-bottom: 10px; color: var(--flappy-yellow); }
        #flappyOverlay {
            display: none;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(22, 33, 62, 0.95);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid var(--flappy-yellow);
            text-align: center;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            z-index: 50;
            width: 80%;
        }
        #flappyOverlay h2 { margin-top: 0; color: #e74c3c; font-size: 24px; }
        #flappyOverlay p { font-size: 18px; font-weight: bold; margin: 15px 0; }

        /* MASTERMIND UI */
        #mmGameContainer { display: flex; flex-direction: column; align-items: center; gap: 10px; width: 100%; }
        .mm-board { background-color: #2d3436; padding: 10px; border-radius: 10px; border: 2px solid #636e72; width: 95%; max-width: 350px; box-sizing: border-box; }
        .mm-row { display: flex; gap: 5px; align-items: center; margin-bottom: 5px; border-bottom: 1px solid #444; padding-bottom: 5px; justify-content: center; }
        .mm-holes { display: flex; gap: 5px; }
        .mm-hole { width: 25px; height: 25px; border-radius: 50%; background-color: #1a1a2e; border: 2px solid #555; cursor: pointer; transition: all 0.2s; }
        .mm-hole.active { box-shadow: 0 0 10px white; border-color: white; }
        
        .mm-feedback { 
            display: flex; 
            flex-direction: row; 
            gap: 2px; 
            width: 50px; 
            height: 25px;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            padding: 0 2px;
        }
        .mm-peg { width: 10px; height: 10px; border-radius: 50%; background-color: #444; border: 1px solid #222; flex-shrink: 0; }
        .mm-peg.black { background-color: #e74c3c; box-shadow: 0 0 5px #e74c3c; } 
        .mm-peg.white { background-color: #fff; box-shadow: 0 0 5px #fff; } 
        
        .mm-selector { display: flex; gap: 8px; margin-top: 15px; background: #16213e; padding: 10px; border-radius: 10px; flex-wrap: wrap; justify-content: center; }
        .mm-btn-color { width: 35px; height: 35px; border-radius: 50%; border: 2px solid white; cursor: pointer; transform: scale(0.9); }

        /* --- CONTROLES MOBILES (D-PAD) --- */
        #mobileControls {
            display: none; /* Cach√© sur PC */
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 220px;
            height: 150px;
            z-index: 9000;
        }
        
        @media (hover: none) and (pointer: coarse) {
            #mobileControls { display: block; } /* Visible sur mobile */
        }

        .dpad-btn {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            user-select: none;
            backdrop-filter: blur(5px);
            touch-action: manipulation;
        }
        .dpad-btn:active { background: rgba(241, 196, 15, 0.5); transform: scale(0.95); }
        
        #btnUp { top: 0; left: 80px; }
        #btnDown { bottom: 0; left: 80px; }
        #btnLeft { top: 45px; left: 0; }
        #btnRight { top: 45px; right: 0; }

        /* Petit bouton action (Jump / Rotate) */
        #actionBtn {
            display: none;
            position: fixed;
            bottom: 40px;
            right: 20px;
            width: 70px;
            height: 70px;
            background: rgba(231, 76, 60, 0.3);
            border-radius: 50%;
            border: 2px solid #e74c3c;
            z-index: 9001;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        @media (hover: none) and (pointer: coarse) { #actionBtn { display: flex; } }
        #actionBtn:active { background: #e74c3c; }

    </style>
</head>
<body>

    <div id="mobileControls">
        <div id="btnUp" class="dpad-btn" ontouchstart="simulateKey(38); return false;">‚ñ≤</div>
        <div id="btnLeft" class="dpad-btn" ontouchstart="simulateKey(37); return false;">‚óÄ</div>
        <div id="btnRight" class="dpad-btn" ontouchstart="simulateKey(39); return false;">‚ñ∂</div>
        <div id="btnDown" class="dpad-btn" ontouchstart="simulateKey(40); return false;">‚ñº</div>
    </div>
    <div id="actionBtn" ontouchstart="simulateKey(32); return false;">ACT</div>

    <div id="vaultOverlay">
        <div id="vaultContent">
            <div id="vaultAuth">
                <h2>üîí S√âCURIT√â</h2>
                <p>Code PIN (1234):</p>
                <input type="password" id="vaultPin" maxlength="4" placeholder="....">
                <div id="vaultError">ACC√àS REFUS√â</div>
                <button style="width:100%; background:#3498db;" onclick="checkVaultCode()">Valider</button>
                <button style="width:100%; background:#95a5a6; margin-top:10px;" onclick="closeVault()">Annuler</button>
            </div>

            <div id="vaultSettings">
                <h2 style="text-align: center;">‚öôÔ∏è HACK CONSOLE</h2>
                
                <h3>üê¶ Flappy Bird</h3>
                <div class="vault-group"><label>Gravit√© (0.25)</label><input type="number" id="vFlappyGrav" value="0.25" step="0.05"></div>
                <div class="vault-group"><label>Espace Tuyaux</label><input type="number" id="vFlappyGap" value="150" min="80" max="300"></div>

                <h3>üèéÔ∏è Tron</h3>
                <div class="vault-group"><label>Vitesse</label><input type="number" id="vTronSpeed" value="80" min="20" max="200"></div>
                <div class="vault-group"><label>Tra√Æn√©e</label><input type="number" id="vTronLen" value="50" min="5" max="500"></div>
                <div class="vault-group" style="justify-content: flex-start; gap: 10px;">
                    <label>Traverser Murs</label>
                    <input type="checkbox" id="vTronWall" style="width: 20px; height: 20px;">
                </div>

                <h3>üèì Pong</h3>
                <div class="vault-group"><label>Vitesse Balle</label><input type="number" id="vPongSpeed" value="5" min="2" max="20"></div>
                <div class="vault-group"><label>Raquette</label><input type="number" id="vPongPad" value="100" min="30" max="200"></div>
                <div class="vault-group"><label>Largeur</label><input type="number" id="vPongW" value="700" min="300" max="1000"></div>
                <div class="vault-group"><label>Hauteur</label><input type="number" id="vPongH" value="500" min="300" max="800"></div>

                <h3>üêç Snake</h3>
                <div class="vault-group"><label>Vitesse</label><input type="number" id="vSnakeSpeed" value="80"></div>
                <div class="vault-group"><label>Taille Map</label><input type="number" id="vSnakeSize" value="20"></div>
                
                <h3>üß± Tetris</h3>
                <div class="vault-group"><label>Vitesse</label><input type="number" id="vTetrisSpeed" value="500"></div>
                <div class="vault-group"><label>Colonnes</label><input type="number" id="vTetrisCols" value="10" min="5" max="20"></div>
                <div class="vault-group"><label>Lignes</label><input type="number" id="vTetrisRows" value="20" min="10" max="30"></div>

                <h3>üí£ D√©mineur</h3>
                <div class="vault-group"><label>Largeur</label><input type="number" id="vMineWidth" value="12"></div>
                <div class="vault-group"><label>Bombes</label><input type="number" id="vMineBombs" value="20"></div>

                <h3>‚ùå‚≠ï Morpion</h3>
                <div class="vault-group"><label>Taille</label><input type="number" id="vTTTSize" value="3" min="3" max="5"></div>
                <div class="vault-group"><label>Aligner</label><input type="number" id="vTTTWin" value="3" min="3" max="5"></div>

                <h3>üî¥üü° Puissance 4</h3>
                <div class="vault-group"><label>Cols</label><input type="number" id="vC4Cols" value="7" min="5" max="8"></div>
                <div class="vault-group"><label>Lignes</label><input type="number" id="vC4Rows" value="6" min="5" max="8"></div>
                <div class="vault-group"><label>Aligner</label><input type="number" id="vC4Win" value="4" min="3" max="6"></div>
                
                <h3>üé® Mastermind</h3>
                <button style="width: 100%; background-color: #fd79a8; margin-bottom: 10px;" onclick="hackMastermind()">üîì D√âCRYPTAGE PARTIEL</button>

                <button style="width: 100%; background-color: #2ecc71; margin-top: 20px;" onclick="saveAndCloseVault()">Sauvegarder</button>
                <button style="width: 100%; background-color: #e67e22; margin-top: 10px;" onclick="resetVaultSettings()">R√©initialiser</button>
                <button style="width: 100%; background-color: #95a5a6; margin-top: 10px;" onclick="closeVault()">Quitter</button>
            </div>
        </div>
    </div>

    <div id="mainHub" class="game-menu-card">
        <div id="vaultBtn" onclick="openVault()">üîí</div>
        <h1>üéÆ ARCADE ZONE</h1>
        <p>S√©lectionnez votre jeu :</p>
        <button class="btn-hub btn-flappy-hub" onclick="loadFlappySystem()">üê¶ FLAPPY BIRD</button>
        <button class="btn-hub btn-tetris-hub" onclick="loadTetrisSystem()">üß± TETRIS</button>
        <button class="btn-hub btn-pong-hub" onclick="loadPongSystem()">üèì PONG</button>
        <button class="btn-hub btn-tron-hub" onclick="loadTronSystem()">üèéÔ∏è TRON</button>
        <button class="btn-hub btn-snake-hub" onclick="loadSnakeSystem()">üêç SNAKE</button>
        <button class="btn-hub btn-mm-hub" onclick="loadMastermindSystem()">üé® MASTERMIND</button>
        <button class="btn-hub btn-mine-hub" onclick="loadMineSystem()">üí£ D√âMINEUR</button>
        <button class="btn-hub btn-ttt-hub" onclick="loadTicTacToeSystem()">‚ùå‚≠ï MORPION</button>
        <button class="btn-hub btn-c4-hub" onclick="loadConnect4System()">üî¥üü° PUISSANCE 4</button>
    </div>

    <div id="flappyRoot">
        <button class="back-to-hub" onclick="backToHub()">üè† Retour</button>
        <div id="flappyMenu" class="game-menu-card">
            <h2>üê¶ FLAPPY BIRD</h2>
            <p>Espace / Clic pour voler</p>
            <button class="level-btn btn-easy" onclick="startFlappy()">JOUER</button>
            <p>Hacking :</p>
            <button class="level-btn btn-custom" onclick="openVault()">üîë Config Coffre</button>
        </div>
        <div id="flappyGameContainer">
            <div id="flappyScoreBoard">Score: <span id="fScore">0</span></div>
            <canvas id="flappyCanvas" width="400" height="600"></canvas>
            
            <div id="flappyOverlay">
                <h2>GAME OVER</h2>
                <p>Score Final : <span id="fFinalScore" style="color: #f1c40f;">0</span></p>
                <button class="level-btn btn-easy" onclick="startFlappy()">üîÑ Rejouer (Entr√©e)</button>
                <button class="level-btn btn-hard" onclick="backToHub()">üè† Quitter</button>
            </div>
        </div>
    </div>

    <div id="pongRoot">
        <button class="back-to-hub" onclick="backToHub()">üè† Retour</button>
        <div id="pongMenu" class="game-menu-card">
            <h2>PONG</h2>
            <p>Souris ou Tactile</p>
            <button class="level-btn btn-easy" onclick="startPong(5, 0.08)">Facile</button>
            <button class="level-btn btn-medium" onclick="startPong(9, 0.12)">Moyen</button>
            <button class="level-btn btn-hard" onclick="startPong(12, 0.2)">Difficile</button>
            <p>Hacking :</p>
            <button class="level-btn btn-custom" onclick="startVaultPong()">üîë Config Coffre</button>
        </div>
        <div id="pongGameContainer">
            <div id="pongScoreBoard"><span id="pScore1">0</span> - <span id="pScore2">0</span></div>
            <canvas id="pongCanvas" width="700" height="500"></canvas>
        </div>
    </div>

    <div id="tronRoot">
        <button class="back-to-hub" onclick="backToHub()">üè† Retour</button>
        <div id="tronMenu" class="game-menu-card">
            <h2>üèéÔ∏è TRON</h2>
            <p>P1: ZQSD | P2: Fl√®ches</p>
            <button class="level-btn btn-pvp" onclick="startTron('pvp')">üë• 2 Joueurs</button>
            <button class="level-btn btn-easy" onclick="startTron('easy')">ü§ñ IA Facile</button>
            <button class="level-btn btn-medium" onclick="startTron('medium')">ü§ñ IA Moyen</button>
            <button class="level-btn btn-hard" onclick="startTron('hard')">ü§ñ IA Difficile</button>
            <p>Hacking :</p>
            <button class="level-btn btn-custom" onclick="openVault()">üîë Config Coffre</button>
        </div>
        <div id="tronGameContainer">
            <div class="tron-score"><span class="p1-tron">P1: <span id="tP1Score">0</span></span> | <span class="p2-tron">P2: <span id="tP2Score">0</span></span></div>
            <canvas id="tronCanvas" width="600" height="400"></canvas>
        </div>
    </div>

    <div id="mmRoot">
        <button class="back-to-hub" onclick="backToHub()">üè† Retour</button>
        <div id="mmMenu" class="game-menu-card">
            <h2>üé® MASTERMIND</h2>
            <p>Code secret 4 couleurs</p>
            <button class="level-btn btn-easy" onclick="startMastermind()">JOUER</button>
            <p>Hacking :</p>
            <button class="level-btn btn-custom" onclick="openVault()">üîë Config Coffre</button>
        </div>
        <div id="mmGameContainer" style="display:none;">
            <div class="mm-board" id="mmBoard">
                </div>
            <div class="mm-selector" id="mmSelector">
                </div>
            <button style="margin-top:15px; width: auto; background-color: #2ecc71;" onclick="submitMmGuess()">VALIDER LIGNE</button>
        </div>
    </div>

    <div id="tetrisRoot">
        <button class="back-to-hub" onclick="backToHub()">üè† Retour</button>
        <div id="tetrisMenu" class="game-menu-card">
            <h2>TETRIS</h2>
            <p>Fl√®ches + Clic rotation</p>
            <button class="level-btn btn-easy" onclick="startTetris(800)">Lent</button>
            <button class="level-btn btn-medium" onclick="startTetris(500)">Normal</button>
            <button class="level-btn btn-hard" onclick="startTetris(200)">Rapide</button>
            <p>Hacking :</p>
            <button class="level-btn btn-custom" onclick="startVaultTetris()">üîë Config Coffre</button>
        </div>
        <div id="tetrisGameContainer">
            <canvas id="tetrisBoard" width="300" height="600"></canvas>
            <div class="tetris-ui">
                <div class="tetris-panel">
                    <h4>SCORE</h4>
                    <span id="tetrisScoreVal">0</span>
                </div>
                <div class="tetris-panel">
                    <h4>SUIVANT</h4>
                    <canvas id="nextPieceCanvas" width="80" height="80"></canvas>
                </div>
            </div>
        </div>
    </div>

    <div id="snakeRoot">
        <button class="back-to-hub" onclick="backToHub()">üè† Retour</button>
        <div id="snakeMenu" class="game-menu-card">
            <h2>SNAKE</h2>
            <label class="checkbox-container"><input type="checkbox" id="snakeWallCheck"> Murs Mortels</label>
            <button class="level-btn btn-easy" onclick="startSnakeGame(150, 20)">Lent</button>
            <button class="level-btn btn-medium" onclick="startSnakeGame(100, 20)">Normal</button>
            <button class="level-btn btn-hard" onclick="startSnakeGame(50, 20)">Rapide</button>
            <p>Hacking :</p>
            <button class="level-btn btn-custom" onclick="startVaultSnake()">üîë Config Coffre</button>
        </div>
        <div id="snakeScoreBoard">Pommes : <span id="snakeScoreVal">0</span></div>
        <canvas id="snakeCanvas" width="400" height="400"></canvas>
    </div>

    <div id="minesweeperRoot">
        <button class="back-to-hub" onclick="backToHub()">üè† Retour</button>
        <div id="mineMenu" class="game-menu-card">
            <h2>D√âMINEUR</h2>
            <button class="level-btn btn-easy" onclick="startMineGame(10, 15)">Facile</button>
            <button class="level-btn btn-medium" onclick="startMineGame(15, 40)">Normal</button>
            <button class="level-btn btn-hard" onclick="startMineGame(20, 80)">Difficile</button>
            <p>Hacking :</p>
            <button class="level-btn btn-custom" onclick="startVaultMine()">üîë Config Coffre</button>
        </div>
        <div id="mineGameContainer">
            <div class="header-mine" id="mineHeader">
                <div>üö© <span id="flagsLeft">0</span></div>
                <button style="padding: 5px 15px; font-size:20px; margin:0; background-color:#e67e22;" onclick="initMineBoard()">üòé</button>
                <div>‚è±Ô∏è <span id="mineTimer">0</span></div>
            </div>
            <div id="grid"></div>
        </div>
    </div>

    <div id="tictactoeRoot">
        <button class="back-to-hub" onclick="backToHub()">üè† Retour</button>
        <div id="tttMenu" class="game-menu-card">
            <h2>MORPION</h2>
            <button class="level-btn btn-pvp" onclick="startTTT('pvp')">üë• 2 Joueurs</button>
            <button class="level-btn btn-easy" onclick="startTTT('cpu-easy')">Facile</button>
            <button class="level-btn btn-medium" onclick="startTTT('cpu-normal')">Normal</button>
            <button class="level-btn btn-hard" onclick="startTTT('cpu-hard')">Difficile</button>
            <p>Hacking :</p>
            <button class="level-btn btn-custom" onclick="startVaultTTT()">üîë Config Coffre</button>
        </div>
        <div id="tttGameContainer">
            <div class="score-board-common">
                <div class="score-box p1-score">X : <span id="scoreX">0</span></div>
                <div class="score-box p2-score">O : <span id="scoreO">0</span></div>
            </div>
            <div id="tttStatus" style="font-size: 24px; margin-bottom: 15px; color: #f1c40f; font-weight: bold;">Tour de : X</div>
            <div id="tttGrid" class="dynamic-grid"></div>
            <div style="margin-top: 20px; display: flex; gap: 15px;">
                <button style="background-color: #27ae60;" onclick="triggerResetTTT()">üîÑ Relancer</button>
                <button style="background-color: #95a5a6;" onclick="backToTTTMenu()">Menu</button>
            </div>
        </div>
    </div>

    <div id="connect4Root">
        <button class="back-to-hub" onclick="backToHub()">üè† Retour</button>
        <div id="c4Menu" class="game-menu-card">
            <h2>PUISSANCE 4</h2>
            <button class="level-btn btn-pvp" onclick="startC4('pvp')">üë• 2 Joueurs</button>
            <button class="level-btn btn-easy" onclick="startC4('cpu-easy')">Facile</button>
            <button class="level-btn btn-medium" onclick="startC4('cpu-normal')">Normal</button>
            <button class="level-btn btn-hard" onclick="startC4('cpu-hard')">Difficile</button>
            <p>Hacking :</p>
            <button class="level-btn btn-custom" onclick="startVaultC4()">üîë Config Coffre</button>
        </div>
        <div id="c4GameContainer">
            <div class="score-board-common">
                <div class="score-box p1-score">R : <span id="c4ScoreRed">0</span></div>
                <div class="score-box p2-score-c4">J : <span id="c4ScoreYellow">0</span></div>
            </div>
            <div id="c4Status" style="font-size: 24px; margin-bottom: 15px; color: #f1c40f; font-weight: bold;">Tour de : ROUGE</div>
            <div id="c4Grid" class="dynamic-grid"></div>
            <div style="margin-top: 20px; display: flex; gap: 15px;">
                <button style="background-color: #27ae60;" onclick="triggerResetC4()">üîÑ Relancer</button>
                <button style="background-color: #95a5a6;" onclick="backToC4Menu()">Menu</button>
            </div>
        </div>
    </div>

    <script>
        // === HELPERS MOBILE ===
        function simulateKey(code) {
            const e = new KeyboardEvent('keydown', { keyCode: code, which: code });
            document.dispatchEvent(e);
        }

        // === GESTION HACK AVEC CODE PIN ===
        let tttSize=3, tttWinLen=3, tttStart='X';
        let c4Rows=6, c4Cols=7, c4WinLen=4, c4Start='R';
        let tConfigSpeed=500, tConfigCols=10, tConfigRows=20;
        let pConfigSpeed=5, pConfigPad=100; 
        let pConfigW=700, pConfigH=500; 
        let tronConfigSpeed = 80, tronConfigWall = false, tronMaxTrail = 50;
        // Flappy Hack
        let fConfigGrav = 0.25;
        let fConfigGap = 150;

        document.getElementById("vaultPin").addEventListener("keypress", function(e) { if (e.key === "Enter") { e.preventDefault(); checkVaultCode(); }});

        function openVault() { 
            document.getElementById('vaultOverlay').style.display='flex'; 
            document.getElementById('vaultAuth').style.display='block';
            document.getElementById('vaultSettings').style.display='none';
            document.getElementById('vaultPin').value='';
            document.getElementById('vaultError').style.display='none';
            document.getElementById('vaultPin').focus();
        }
        function closeVault() { document.getElementById('vaultOverlay').style.display='none'; }
        
        function checkVaultCode() { 
            if(document.getElementById('vaultPin').value==="1234"){
                document.getElementById('vaultAuth').style.display='none';
                document.getElementById('vaultSettings').style.display='block';
            } else {
                document.getElementById('vaultError').style.display='block';
            } 
        }

        function saveAndCloseVault() {
            let ts=parseInt(document.getElementById('vTTTSize').value); if(ts<3)ts=3;if(ts>5)ts=5; tttSize=ts; // Limit mobile
            let tw=parseInt(document.getElementById('vTTTWin').value); if(tw<3)tw=3;if(tw>ts)tw=ts; tttWinLen=tw;
            let cr=parseInt(document.getElementById('vC4Rows').value); if(cr<5)cr=5;if(cr>8)cr=8; c4Rows=cr;
            let cc=parseInt(document.getElementById('vC4Cols').value); if(cc<5)cc=5;if(cc>8)cc=8; c4Cols=cc;
            let cw=parseInt(document.getElementById('vC4Win').value); if(cw<3)cw=3;if(cw>Math.max(cr,cc))cw=Math.max(cr,cc); c4WinLen=cw;
            tConfigSpeed = parseInt(document.getElementById('vTetrisSpeed').value)||500;
            tConfigCols = parseInt(document.getElementById('vTetrisCols').value)||10;
            tConfigRows = parseInt(document.getElementById('vTetrisRows').value)||20;
            
            pConfigSpeed = parseInt(document.getElementById('vPongSpeed').value) || 5;
            pConfigPad = parseInt(document.getElementById('vPongPad').value) || 100;
            pConfigW = parseInt(document.getElementById('vPongW').value) || 700;
            pConfigH = parseInt(document.getElementById('vPongH').value) || 500;

            tronConfigSpeed = parseInt(document.getElementById('vTronSpeed').value) || 80;
            tronMaxTrail = parseInt(document.getElementById('vTronLen').value) || 50;
            tronConfigWall = document.getElementById('vTronWall').checked;

            fConfigGrav = parseFloat(document.getElementById('vFlappyGrav').value) || 0.25;
            fConfigGap = parseInt(document.getElementById('vFlappyGap').value) || 150;

            closeVault(); alert("‚úÖ Config Sauvegard√©e !");
        }

        function resetVaultSettings() {
            // Variables
            tttSize=3; tttWinLen=3;
            c4Rows=6; c4Cols=7; c4WinLen=4;
            tConfigSpeed=500; tConfigCols=10; tConfigRows=20;
            pConfigSpeed=5; pConfigPad=100; pConfigW=700; pConfigH=500;
            tronConfigSpeed=80; tronMaxTrail=50; tronConfigWall=false;
            fConfigGrav=0.25; fConfigGap=150;

            // Inputs
            document.getElementById('vPongSpeed').value = 5;
            document.getElementById('vPongPad').value = 100;
            document.getElementById('vPongW').value = 700;
            document.getElementById('vPongH').value = 500;
            document.getElementById('vSnakeSpeed').value = 80;
            document.getElementById('vSnakeSize').value = 20;
            document.getElementById('vTetrisSpeed').value = 500;
            document.getElementById('vTetrisCols').value = 10;
            document.getElementById('vTetrisRows').value = 20;
            document.getElementById('vMineWidth').value = 12;
            document.getElementById('vMineBombs').value = 20;
            document.getElementById('vTTTSize').value = 3;
            document.getElementById('vTTTWin').value = 3;
            document.getElementById('vC4Cols').value = 7;
            document.getElementById('vC4Rows').value = 6;
            document.getElementById('vC4Win').value = 4;
            document.getElementById('vTronSpeed').value = 80;
            document.getElementById('vTronLen').value = 50;
            document.getElementById('vTronWall').checked = false;
            document.getElementById('vFlappyGrav').value = 0.25;
            document.getElementById('vFlappyGap').value = 150;

            alert("üîÑ Param√®tres r√©initialis√©s !");
        }

        function startVaultSnake() { startSnakeGame(parseInt(document.getElementById('vSnakeSpeed').value)||100, parseInt(document.getElementById('vSnakeSize').value)||20); }
        function startVaultMine() { startMineGame(parseInt(document.getElementById('vMineWidth').value)||10, parseInt(document.getElementById('vMineBombs').value)||10); }
        function startVaultTTT() { startTTT('pvp'); }
        function startVaultC4() { startC4('pvp'); }
        function startVaultTetris() { startTetris(tConfigSpeed, tConfigCols, tConfigRows); }
        function startVaultPong() { startPong(pConfigSpeed, 0.15); }

        // --- NAV ---
        const hub=document.getElementById('mainHub');
        const snakeRoot=document.getElementById('snakeRoot');
        const mineRoot=document.getElementById('minesweeperRoot');
        const tttRoot=document.getElementById('tictactoeRoot');
        const c4Root=document.getElementById('connect4Root');
        const tetrisRoot=document.getElementById('tetrisRoot');
        const pongRoot=document.getElementById('pongRoot');
        const tronRoot=document.getElementById('tronRoot');
        const mmRoot=document.getElementById('mmRoot');
        const flappyRoot=document.getElementById('flappyRoot');
        
        let currentGameMode = null; 

        function backToHub() { 
            stopSnake(); stopMine(); stopTetris(); stopPong(); stopTron(); stopFlappy();
            snakeRoot.style.display='none'; 
            mineRoot.style.display='none'; 
            tttRoot.style.display='none'; 
            c4Root.style.display='none'; 
            tetrisRoot.style.display='none'; 
            pongRoot.style.display='none';
            tronRoot.style.display='none';
            mmRoot.style.display='none';
            flappyRoot.style.display='none';
            hub.style.display='block'; 
            currentGameMode=null; 
        }

        function loadSnakeSystem() { hub.style.display='none'; snakeRoot.style.display='flex'; document.getElementById('snakeMenu').style.display='block'; document.getElementById('snakeCanvas').style.display='none'; document.getElementById('snakeScoreBoard').style.display='none'; }
        function loadMineSystem() { hub.style.display='none'; mineRoot.style.display='flex'; document.getElementById('mineMenu').style.display='block'; document.getElementById('mineGameContainer').style.display='none'; }
        function loadTicTacToeSystem() { hub.style.display='none'; tttRoot.style.display='flex'; document.getElementById('tttMenu').style.display='block'; document.getElementById('tttGameContainer').style.display='none'; }
        function loadConnect4System() { hub.style.display='none'; c4Root.style.display='flex'; document.getElementById('c4Menu').style.display='block'; document.getElementById('c4GameContainer').style.display='none'; }
        function loadTetrisSystem() { hub.style.display='none'; tetrisRoot.style.display='flex'; document.getElementById('tetrisMenu').style.display='block'; document.getElementById('tetrisGameContainer').style.display='none'; }
        function loadPongSystem() { hub.style.display='none'; pongRoot.style.display='flex'; document.getElementById('pongMenu').style.display='block'; document.getElementById('pongGameContainer').style.display='none'; }
        function loadTronSystem() { hub.style.display='none'; tronRoot.style.display='flex'; document.getElementById('tronMenu').style.display='block'; document.getElementById('tronGameContainer').style.display='none'; }
        function loadMastermindSystem() { hub.style.display='none'; mmRoot.style.display='flex'; document.getElementById('mmMenu').style.display='block'; document.getElementById('mmGameContainer').style.display='none'; }
        function loadFlappySystem() { hub.style.display='none'; flappyRoot.style.display='flex'; document.getElementById('flappyMenu').style.display='block'; document.getElementById('flappyGameContainer').style.display='none'; }

        // ============================
        // === FLAPPY BIRD LOGIC (CORRECTED) ===
        // ============================
        const fCanvas = document.getElementById('flappyCanvas');
        const fCtx = fCanvas.getContext('2d');
        const fScoreEl = document.getElementById('fScore');
        
        let flappyBird = { x: 50, y: 150, w: 20, h: 20, velocity: 0 };
        let flappyPipes = [];
        let flappyScore = 0;
        let flappyLoopId;
        let flappyFrame = 0;
        const flappySpeed = 2;
        let fGameState = 'ready'; // ready, playing, over

        function startFlappy() {
            document.getElementById('flappyMenu').style.display = 'none';
            document.getElementById('flappyGameContainer').style.display = 'flex';
            document.getElementById('flappyOverlay').style.display = 'none'; // Hide game over
            fCanvas.style.display = 'block';
            currentGameMode = 'flappy';
            
            // Reset Vars
            flappyBird = { x: 50, y: 300, w: 20, h: 20, velocity: 0 };
            flappyPipes = [];
            flappyScore = 0;
            fScoreEl.innerText = 0;
            flappyFrame = 0;
            fGameState = 'ready';

            // Draw initial state (Waiting for click)
            if(flappyLoopId) cancelAnimationFrame(flappyLoopId);
            drawFlappy(); 
            fCtx.fillStyle = "white";
            fCtx.font = "20px Courier New";
            fCtx.fillText("Clic ou Espace", 110, 200);
            fCtx.fillText("pour voler !", 130, 230);
        }

        function stopFlappy() {
            if(flappyLoopId) cancelAnimationFrame(flappyLoopId);
        }

        function loopFlappy() {
            if(currentGameMode !== 'flappy' || fGameState !== 'playing') return;

            // Physics
            flappyBird.velocity += fConfigGrav;
            flappyBird.y += flappyBird.velocity;

            // Collision Sol / Plafond
            if(flappyBird.y + flappyBird.h >= fCanvas.height || flappyBird.y <= 0) {
                gameOverFlappy();
                return;
            }

            // Pipes
            if(flappyFrame % 180 === 0) { 
                let topH = Math.random() * (fCanvas.height - fConfigGap - 40) + 20; 
                flappyPipes.push({ x: fCanvas.width, y: 0, w: 40, h: topH, passed: false });
                flappyPipes.push({ x: fCanvas.width, y: topH + fConfigGap, w: 40, h: fCanvas.height - (topH + fConfigGap), passed: false });
            }
            flappyFrame++;

            // Move & Check
            for(let i=0; i<flappyPipes.length; i++) {
                let p = flappyPipes[i];
                p.x -= flappySpeed;

                if(flappyBird.x < p.x + p.w && flappyBird.x + flappyBird.w > p.x &&
                   flappyBird.y < p.y + p.h && flappyBird.y + flappyBird.h > p.y) {
                    gameOverFlappy();
                    return;
                }

                if(p.y === 0 && p.x + p.w < flappyBird.x && !p.passed) {
                    flappyScore++;
                    fScoreEl.innerText = flappyScore;
                    p.passed = true;
                }
            }
            // Remove old
            if(flappyPipes.length > 0 && flappyPipes[0].x < -50) {
                flappyPipes.shift(); flappyPipes.shift();
            }

            drawFlappy();
            flappyLoopId = requestAnimationFrame(loopFlappy);
        }

        function drawFlappy() {
            fCtx.fillStyle = '#0a0a12';
            fCtx.fillRect(0,0,fCanvas.width, fCanvas.height);
            
            fCtx.fillStyle = '#2ecc71';
            fCtx.shadowBlur = 10; fCtx.shadowColor = "#2ecc71";
            for(let p of flappyPipes) {
                fCtx.fillRect(p.x, p.y, p.w, p.h);
            }
            fCtx.shadowBlur = 0;

            fCtx.fillStyle = '#f1c40f';
            fCtx.fillRect(flappyBird.x, flappyBird.y, flappyBird.w, flappyBird.h);
            fCtx.fillStyle = '#000';
            fCtx.fillRect(flappyBird.x + 12, flappyBird.y + 4, 4, 4);
        }

        function jumpFlappy() {
            if(fGameState === 'ready') {
                fGameState = 'playing';
                flappyBird.velocity = -5;
                loopFlappy();
            } else if (fGameState === 'playing') {
                flappyBird.velocity = -5;
            }
        }

        function gameOverFlappy() {
            fGameState = 'over';
            stopFlappy();
            // Show Overlay
            document.getElementById('fFinalScore').innerText = flappyScore;
            document.getElementById('flappyOverlay').style.display = 'block';
        }

        // ============================
        // === MASTERMIND LOGIC ===
        // ============================
        const mmColors = ['#e74c3c', '#2ecc71', '#3498db', '#f1c40f', '#9b59b6', '#00cec9']; // R, G, B, Y, P, C
        let mmSecret = [];
        let mmTurn = 0;
        let mmCurrentGuess = [];
        let mmGameOver = false;

        function startMastermind() {
            document.getElementById('mmMenu').style.display = 'none';
            document.getElementById('mmGameContainer').style.display = 'flex';
            currentGameMode = 'mastermind';
            
            // Generate secret
            mmSecret = [];
            for(let i=0; i<4; i++) mmSecret.push(Math.floor(Math.random() * 6));
            
            mmTurn = 0;
            mmCurrentGuess = [];
            mmGameOver = false;
            
            renderMastermind();
        }

        function renderMastermind() {
            const board = document.getElementById('mmBoard');
            board.innerHTML = '';
            
            // Previous rows
            for(let i=0; i<10; i++) {
                const row = document.createElement('div');
                row.className = 'mm-row';
                row.id = `mmRow${i}`;
                
                // Holes
                const holesDiv = document.createElement('div');
                holesDiv.className = 'mm-holes';
                for(let j=0; j<4; j++) {
                    const hole = document.createElement('div');
                    hole.className = 'mm-hole';
                    // Active row filling
                    if(i === mmTurn && mmCurrentGuess[j] !== undefined) {
                        hole.style.backgroundColor = mmColors[mmCurrentGuess[j]];
                    }
                    hole.id = `mmHole_${i}_${j}`;
                    holesDiv.appendChild(hole);
                }
                row.appendChild(holesDiv);

                // Feedback
                const feedbackDiv = document.createElement('div');
                feedbackDiv.className = 'mm-feedback';
                feedbackDiv.id = `mmFeed${i}`;
                row.appendChild(feedbackDiv);

                board.appendChild(row);
            }

            // Selector
            const selector = document.getElementById('mmSelector');
            selector.innerHTML = '';
            mmColors.forEach((col, idx) => {
                const btn = document.createElement('div');
                btn.className = 'mm-btn-color';
                btn.style.backgroundColor = col;
                btn.onclick = () => mmInputColor(idx);
                selector.appendChild(btn);
            });
        }

        function mmInputColor(colorIdx) {
            if(mmGameOver || mmCurrentGuess.length >= 4) return;
            mmCurrentGuess.push(colorIdx);
            // Update visual directly
            const hole = document.getElementById(`mmHole_${mmTurn}_${mmCurrentGuess.length-1}`);
            if(hole) hole.style.backgroundColor = mmColors[colorIdx];
        }

        function submitMmGuess() {
            if(mmGameOver || mmCurrentGuess.length !== 4) {
                alert("Remplissez la ligne (4 couleurs) !");
                return;
            }

            // Logic to calculate pegs (Corrected)
            let blacks = 0;
            let whites = 0;
            
            let tempSecret = [...mmSecret];
            let tempGuess = [...mmCurrentGuess];

            // 1. Blacks
            for(let i=0; i<4; i++) {
                if(tempGuess[i] === tempSecret[i]) {
                    blacks++;
                    tempSecret[i] = -1; // Mark handled
                    tempGuess[i] = -2; // Mark handled
                }
            }

            // 2. Whites
            for(let i=0; i<4; i++) {
                if(tempGuess[i] !== -2) { 
                    let idx = tempSecret.indexOf(tempGuess[i]);
                    if(idx !== -1) {
                        whites++;
                        tempSecret[idx] = -1; // Mark handled
                    }
                }
            }

            // Display Feedback (Sorted: Black first, then White)
            const feedDiv = document.getElementById(`mmFeed${mmTurn}`);
            for(let k=0; k<blacks; k++) {
                const p = document.createElement('div'); p.className='mm-peg black'; feedDiv.appendChild(p);
            }
            for(let k=0; k<whites; k++) {
                const p = document.createElement('div'); p.className='mm-peg white'; feedDiv.appendChild(p);
            }

            // Check Win
            if(blacks === 4) {
                mmGameOver = true;
                alert("GAGN√â ! Code trouv√© !");
                return;
            }

            mmTurn++;
            mmCurrentGuess = [];
            if(mmTurn >= 10) {
                mmGameOver = true;
                alert("PERDU ! Le code √©tait : " + mmSecret.map(i=>['R','V','B','J','Vi','C'][i]).join(', '));
            }
        }

        function hackMastermind() {
            if(currentGameMode !== 'mastermind' || mmGameOver) {
                alert("Lancez une partie d'abord !");
                closeVault();
                return;
            }
            const pos = Math.floor(Math.random() * 4);
            const colIdx = mmSecret[pos];
            const colNames = ['Rouge', 'Vert', 'Bleu', 'Jaune', 'Violet', 'Cyan'];
            alert(`HACK INFO:\nPosition ${pos+1} est ${colNames[colIdx]}`);
            closeVault();
        }

        // ============================
        // === PONG LOGIC ===
        // ============================
        const pCanvas = document.getElementById('pongCanvas');
        const pCtx = pCanvas.getContext('2d');
        const pScore1El = document.getElementById('pScore1');
        const pScore2El = document.getElementById('pScore2');

        let pBall = { x: 350, y: 250, r: 10, dx: 4, dy: 4 }; 
        let pPad1 = { x: 10, y: 200, w: 15, h: 100, score: 0 }; 
        let pPad2 = { x: 670, y: 200, w: 15, h: 100, score: 0 }; 
        let pDifficulty = 0.1; 
        let pLoopId;

        function startPong(speed, diff) {
            document.getElementById('pongMenu').style.display = 'none';
            document.getElementById('pongGameContainer').style.display = 'flex';
            pCanvas.style.display = 'block'; 
            currentGameMode = 'pong';

            pCanvas.width = pConfigW;
            pCanvas.height = pConfigH;

            pPad1.score = 0; pPad2.score = 0;
            pPad1.h = pConfigPad; pPad2.h = pConfigPad; 
            pPad2.x = pCanvas.width - 25; 

            pScore1El.innerText = 0; pScore2El.innerText = 0;
            pDifficulty = diff;
            
            const dirX = Math.random() > 0.5 ? 1 : -1;
            pBall.dx = speed * dirX;
            pBall.dy = speed;
            resetBall();

            if(pLoopId) cancelAnimationFrame(pLoopId);
            loopPong();
        }

        function stopPong() {
            if(pLoopId) cancelAnimationFrame(pLoopId);
        }

        function resetBall() {
            pBall.x = pCanvas.width / 2;
            pBall.y = pCanvas.height / 2;
            let speed = Math.abs(pBall.dx);
            pBall.dx = -pBall.dx; 
            pBall.dy = (Math.random() * speed * 2) - speed; 
        }

        function loopPong() {
            if(currentGameMode !== 'pong') return;

            pBall.x += pBall.dx;
            pBall.y += pBall.dy;

            // FIX: Balle coinc√©e dans le sol
            if(pBall.y - pBall.r < 0) {
                pBall.y = pBall.r; // Sort de la paroi
                pBall.dy = -pBall.dy;
            }
            if(pBall.y + pBall.r > pCanvas.height) {
                pBall.y = pCanvas.height - pBall.r; // Sort de la paroi
                pBall.dy = -pBall.dy;
            }

            let targetY = pBall.y - (pPad2.h / 2);
            pPad2.y += (targetY - pPad2.y) * pDifficulty;
            if(pPad2.y < 0) pPad2.y = 0;
            if(pPad2.y + pPad2.h > pCanvas.height) pPad2.y = pCanvas.height - pPad2.h;

            if(pBall.x - pBall.r < pPad1.x + pPad1.w && pBall.y > pPad1.y && pBall.y < pPad1.y + pPad1.h) {
                pBall.dx = Math.abs(pBall.dx); 
                let hitPoint = pBall.y - (pPad1.y + pPad1.h/2);
                pBall.dy = hitPoint * 0.2; 
                if(pBall.dx < 15) pBall.dx *= 1.03;
            }
            if(pBall.x + pBall.r > pPad2.x && pBall.y > pPad2.y && pBall.y < pPad2.y + pPad2.h) {
                pBall.dx = -Math.abs(pBall.dx);
                let hitPoint = pBall.y - (pPad2.y + pPad2.h/2);
                pBall.dy = hitPoint * 0.2;
            }

            if(pBall.x < 0) {
                pPad2.score++;
                pScore2El.innerText = pPad2.score;
                resetBall();
            } else if(pBall.x > pCanvas.width) {
                pPad1.score++;
                pScore1El.innerText = pPad1.score;
                resetBall();
            }

            drawPong();
            pLoopId = requestAnimationFrame(loopPong);
        }

        function drawPong() {
            pCtx.fillStyle = '#000';
            pCtx.fillRect(0, 0, pCanvas.width, pCanvas.height);
            pCtx.fillStyle = '#34495e';
            for(let i=0; i<pCanvas.height; i+=30) {
                pCtx.fillRect(pCanvas.width/2 - 2, i, 4, 20);
            }
            pCtx.fillStyle = '#fff';
            pCtx.shadowBlur = 10; pCtx.shadowColor = "white";
            pCtx.fillRect(pPad1.x, pPad1.y, pPad1.w, pPad1.h);
            pCtx.fillRect(pPad2.x, pPad2.y, pPad2.w, pPad2.h);
            pCtx.shadowBlur = 0;
            pCtx.beginPath();
            pCtx.arc(pBall.x, pBall.y, pBall.r, 0, Math.PI*2);
            pCtx.fillStyle = '#e17055'; 
            pCtx.fill();
            pCtx.closePath();
        }

        pCanvas.addEventListener('mousemove', (e) => {
            if(currentGameMode !== 'pong') return;
            const rect = pCanvas.getBoundingClientRect();
            const scaleY = pCanvas.height / rect.height; // Important pour le redimensionnement
            let mouseY = (e.clientY - rect.top) * scaleY;
            pPad1.y = mouseY - (pPad1.h/2);
            if(pPad1.y < 0) pPad1.y = 0;
            if(pPad1.y + pPad1.h > pCanvas.height) pPad1.y = pCanvas.height - pPad1.h;
        });

        pCanvas.addEventListener('touchmove', (e) => {
            if(currentGameMode !== 'pong') return;
            e.preventDefault(); 
            const rect = pCanvas.getBoundingClientRect();
            const scaleY = pCanvas.height / rect.height; // Important pour le redimensionnement
            let touchY = (e.touches[0].clientY - rect.top) * scaleY;
            pPad1.y = touchY - (pPad1.h/2);
            if(pPad1.y < 0) pPad1.y = 0;
            if(pPad1.y + pPad1.h > pCanvas.height) pPad1.y = pCanvas.height - pPad1.h;
        }, {passive: false});

        // ============================
        // === TRON LOGIC (V4 - NO VISUAL GLITCH) ===
        // ============================
        const trCanvas = document.getElementById('tronCanvas');
        const trCtx = trCanvas.getContext('2d');
        let tronGridSize = 10;
        let tronP1 = { x: 10, y: 20, dx: 1, dy: 0, color: '#00fff2', dead: false, score: 0, trail: [] };
        let tronP2 = { x: 50, y: 20, dx: -1, dy: 0, color: '#ff6b6b', dead: false, score: 0, trail: [] };
        let tronGrid = []; 
        let tronInterval, tronIsCPU = false;
        let tronAiDifficulty = 'medium';
        let tP1NextDir = { dx: 1, dy: 0 };
        let tP2NextDir = { dx: -1, dy: 0 };

        function startTron(mode) {
            document.getElementById('tronMenu').style.display = 'none';
            document.getElementById('tronGameContainer').style.display = 'flex';
            trCanvas.style.display = 'block';
            currentGameMode = 'tron';
            
            if(mode === 'pvp') {
                tronIsCPU = false;
            } else {
                tronIsCPU = true;
                tronAiDifficulty = mode;
            }
            
            const cols = trCanvas.width / tronGridSize;
            const rows = trCanvas.height / tronGridSize;
            tronGrid = Array(rows).fill(null).map(() => Array(cols).fill(0));

            tronP1.x = 5; tronP1.y = Math.floor(rows/2);
            tronP1.dx = 1; tronP1.dy = 0; tP1NextDir = { dx: 1, dy: 0 };
            tronP1.dead = false; tronP1.trail = [];
            tronGrid[tronP1.y][tronP1.x] = 1;
            tronP1.trail.push({x: tronP1.x, y: tronP1.y});

            tronP2.x = cols - 6; tronP2.y = Math.floor(rows/2);
            tronP2.dx = -1; tronP2.dy = 0; tP2NextDir = { dx: -1, dy: 0 };
            tronP2.dead = false; tronP2.trail = [];
            tronGrid[tronP2.y][tronP2.x] = 2;
            tronP2.trail.push({x: tronP2.x, y: tronP2.y});

            if(tronInterval) clearInterval(tronInterval);
            tronInterval = setInterval(updateTron, tronConfigSpeed);
            drawTron(); // Premier dessin
        }

        function stopTron() { clearInterval(tronInterval); }

        function updateTron() {
            const cols = trCanvas.width / tronGridSize;
            const rows = trCanvas.height / tronGridSize;

            tronP1.dx = tP1NextDir.dx; tronP1.dy = tP1NextDir.dy;
            tronP2.dx = tP2NextDir.dx; tronP2.dy = tP2NextDir.dy;

            if(tronIsCPU && !tronP2.dead) tronAiMove();

            // === UPDATE P1 ===
            if(!tronP1.dead) {
                let nextX = tronP1.x + tronP1.dx;
                let nextY = tronP1.y + tronP1.dy;

                // Wall Check / Wrap
                if(nextX < 0 || nextX >= cols || nextY < 0 || nextY >= rows) {
                    if(tronConfigWall) {
                        if(nextX < 0) nextX = cols - 1; if(nextX >= cols) nextX = 0;
                        if(nextY < 0) nextY = rows - 1; if(nextY >= rows) nextY = 0;
                    } else {
                        tronP1.dead = true;
                    }
                }

                if(!tronP1.dead && tronGrid[nextY][nextX] !== 0) {
                    tronP1.dead = true;
                }

                if(!tronP1.dead) {
                    tronP1.x = nextX; tronP1.y = nextY;
                    tronGrid[nextY][nextX] = 1;
                    tronP1.trail.push({x: nextX, y: nextY});
                    if(tronP1.trail.length > tronMaxTrail) {
                        let rem = tronP1.trail.shift();
                        if(tronGrid[rem.y][rem.x] === 1) tronGrid[rem.y][rem.x] = 0;
                    }
                }
            }

            // === UPDATE P2 ===
            if(!tronP2.dead) {
                let nextX = tronP2.x + tronP2.dx;
                let nextY = tronP2.y + tronP2.dy;

                if(nextX < 0 || nextX >= cols || nextY < 0 || nextY >= rows) {
                    if(tronConfigWall) {
                        if(nextX < 0) nextX = cols - 1; if(nextX >= cols) nextX = 0;
                        if(nextY < 0) nextY = rows - 1; if(nextY >= rows) nextY = 0;
                    } else {
                        tronP2.dead = true;
                    }
                }

                if(!tronP2.dead && tronGrid[nextY][nextX] !== 0) {
                    tronP2.dead = true;
                }

                if(!tronP2.dead) {
                    tronP2.x = nextX; tronP2.y = nextY;
                    tronGrid[nextY][nextX] = 2;
                    tronP2.trail.push({x: nextX, y: nextY});
                    if(tronP2.trail.length > tronMaxTrail) {
                        let rem = tronP2.trail.shift();
                        if(tronGrid[rem.y][rem.x] === 2) tronGrid[rem.y][rem.x] = 0;
                    }
                }
            }

            drawTron();

            if(tronP1.dead || tronP2.dead) {
                clearInterval(tronInterval);
                setTimeout(() => {
                    if(tronP1.dead && tronP2.dead) alert("Collision mutuelle ! √âgalit√© !");
                    else if(tronP1.dead) { alert("P2 (Rouge) Gagne !"); tronP2.score++; document.getElementById('tP2Score').innerText = tronP2.score; }
                    else { alert("P1 (Cyan) Gagne !"); tronP1.score++; document.getElementById('tP1Score').innerText = tronP1.score; }
                    startTron(tronIsCPU ? tronAiDifficulty : 'pvp');
                }, 100);
            }
        }

        function drawTron() {
            trCtx.clearRect(0, 0, trCanvas.width, trCanvas.height);
            trCtx.fillStyle = '#000'; trCtx.fillRect(0,0,trCanvas.width, trCanvas.height);
            drawTronTrail(tronP1);
            drawTronTrail(tronP2);
            trCtx.shadowBlur = 0;
            drawTronBike(tronP1);
            drawTronBike(tronP2);
        }

        function drawTronTrail(p) {
            if(p.trail.length === 0) return;
            trCtx.beginPath();
            trCtx.strokeStyle = p.color;
            trCtx.lineWidth = tronGridSize / 2;
            trCtx.lineCap = 'round';
            trCtx.lineJoin = 'round';
            trCtx.shadowBlur = 15;
            trCtx.shadowColor = p.color;

            // Move to start
            trCtx.moveTo(p.trail[0].x * tronGridSize + tronGridSize/2, p.trail[0].y * tronGridSize + tronGridSize/2);

            for(let i=1; i<p.trail.length; i++) {
                let prev = p.trail[i-1];
                let curr = p.trail[i];

                // FIX: Check for wrap-around (large distance)
                if(Math.abs(curr.x - prev.x) > 1 || Math.abs(curr.y - prev.y) > 1) {
                    // Lift pen and move to new spot
                    trCtx.moveTo(curr.x * tronGridSize + tronGridSize/2, curr.y * tronGridSize + tronGridSize/2);
                } else {
                    // Draw line
                    trCtx.lineTo(curr.x * tronGridSize + tronGridSize/2, curr.y * tronGridSize + tronGridSize/2);
                }
            }

            // Connect last trail point to head
            let last = p.trail[p.trail.length - 1];
            if(Math.abs(p.x - last.x) > 1 || Math.abs(p.y - last.y) > 1) {
                // Do nothing (jump)
            } else {
                trCtx.lineTo(p.x * tronGridSize + tronGridSize/2, p.y * tronGridSize + tronGridSize/2);
            }

            trCtx.stroke();
        }

        function drawTronBike(p) {
            const gs = tronGridSize;
            const cx = p.x * gs + gs/2;
            const cy = p.y * gs + gs/2;
            trCtx.save();
            trCtx.translate(cx, cy);
            let angle = 0;
            if(p.dx === 1) angle = 0;
            else if(p.dx === -1) angle = Math.PI;
            else if(p.dy === 1) angle = Math.PI/2;
            else if(p.dy === -1) angle = -Math.PI/2;
            trCtx.rotate(angle);
            trCtx.fillStyle = p.color;
            const bikeLen = gs * 1.2;
            const bikeWid = gs * 0.6;
            trCtx.fillRect(-bikeLen/2, -bikeWid/2, bikeLen, bikeWid);
            trCtx.fillStyle = '#fff';
            trCtx.fillRect(-bikeLen/2 + 2, -bikeWid/4, bikeLen/3, bikeWid/2);
            trCtx.restore();
        }

        function tronAiMove() {
            const cols = trCanvas.width / tronGridSize;
            const rows = trCanvas.height / tronGridSize;
            const moves = [{dx:0, dy:-1}, {dx:0, dy:1}, {dx:-1, dy:0}, {dx:1, dy:0}];
            const validMoves = moves.filter(m => !(m.dx === -tronP2.dx && m.dy === -tronP2.dy));
            
            // --- IA FACILE ---
            if (tronAiDifficulty === 'easy') {
                let fwdX = tronP2.x + tronP2.dx;
                let fwdY = tronP2.y + tronP2.dy;
                let fwdSafe = true;

                if(fwdX < 0 || fwdX >= cols || fwdY < 0 || fwdY >= rows) {
                    if(!tronConfigWall) fwdSafe = false;
                    else { if(fwdX<0) fwdX=cols-1; if(fwdX>=cols) fwdX=0; if(fwdY<0) fwdY=rows-1; if(fwdY>=rows) fwdY=0; }
                }
                if(fwdSafe && tronGrid[fwdY][fwdX] !== 0) fwdSafe = false;

                if(fwdSafe && Math.random() < 0.95) {
                    tP2NextDir = {dx: tronP2.dx, dy: tronP2.dy};
                    return;
                }

                const safeOptions = [];
                for(let m of validMoves) {
                     let tx = tronP2.x + m.dx; let ty = tronP2.y + m.dy;
                     let isSafe = true;
                     if(tx < 0 || tx >= cols || ty < 0 || ty >= rows) {
                        if(!tronConfigWall) isSafe = false;
                        else { if(tx<0) tx=cols-1; if(tx>=cols) tx=0; if(ty<0) ty=rows-1; if(ty>=rows) ty=0; }
                     }
                     if(isSafe && tronGrid[ty][tx] !== 0) isSafe = false;
                     if(isSafe) safeOptions.push(m);
                }

                if(safeOptions.length > 0) {
                    tP2NextDir = safeOptions[Math.floor(Math.random() * safeOptions.length)];
                }
                return;
            }

            // --- IA MEDIUM / HARD ---
            let bestMove = null;
            let bestScore = -99999;

            for(let m of validMoves) {
                let tx = tronP2.x + m.dx; 
                let ty = tronP2.y + m.dy;
                
                let blocked = false;
                if(tx < 0 || tx >= cols || ty < 0 || ty >= rows) blocked = !tronConfigWall;
                else if(tronGrid[ty][tx] !== 0) blocked = true;

                if(!blocked) {
                    let safety = 0;
                    let r = 0;
                    let rtx = tx, rty = ty;
                    while(r < 40) { 
                        rtx += m.dx; rty += m.dy;
                        if(rtx < 0 || rtx >= cols || rty < 0 || rty >= rows) {
                            if(!tronConfigWall) break;
                            else { if(rtx<0)rtx=cols-1; if(rtx>=cols)rtx=0; if(rty<0)rty=rows-1; if(rty>=rows)rty=0; }
                        }
                        if(tronGrid[rty][rtx] !== 0) break;
                        r++;
                    }
                    safety = r;

                    let aggression = 0;
                    if(tronAiDifficulty === 'hard') {
                        let p1FutX = tronP1.x + tronP1.dx * 2;
                        let p1FutY = tronP1.y + tronP1.dy * 2;
                        let dist = Math.abs(tx - p1FutX) + Math.abs(ty - p1FutY);
                        aggression = -dist; 
                        if(safety < 5) aggression = -1000; 
                    }

                    let score = (tronAiDifficulty === 'medium') ? safety : (safety * 2 + aggression);

                    if(score > bestScore) {
                        bestScore = score;
                        bestMove = m;
                    }
                }
            }

            if(bestMove) {
                tP2NextDir = bestMove;
            }
        }

        // ============================
        // === TETRIS LOGIC ===
        // ============================
        const tCanvas = document.getElementById('tetrisBoard');
        const tCtx = tCanvas.getContext('2d');
        const nCanvas = document.getElementById('nextPieceCanvas');
        const nCtx = nCanvas.getContext('2d');
        const tScoreEl = document.getElementById('tetrisScoreVal');

        let tCols=10, tRows=20, tBlockSize=30, tSpeed=500;
        let tBoard = [], tScore = 0, tGameOver = false, tInterval, tIsAnimating = false;
        let tPiece = null, tNextPiece = null;

        const SHAPES = [
            [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]], 
            [[0,1,0],[1,1,1],[0,0,0]], 
            [[0,1,0],[0,1,0],[0,1,1]], 
            [[0,1,0],[0,1,0],[1,1,0]], 
            [[1,1],[1,1]], 
            [[1,1,0],[0,1,1],[0,0,0]], 
            [[0,1,1],[1,1,0],[0,0,0]]  
        ];
        const COLORS = ['cyan', 'purple', 'orange', 'blue', 'yellow', 'red', 'green'];

        function startTetris(speed, c=10, r=20) {
            tSpeed = speed; tCols = c; tRows = r;
            document.getElementById('tetrisMenu').style.display = 'none';
            document.getElementById('tetrisGameContainer').style.display = 'flex';
            tCanvas.style.display = 'block'; 
            currentGameMode = 'tetris';
            
            tBlockSize = 30;
            tCanvas.width = tCols * tBlockSize;
            tCanvas.height = tRows * tBlockSize;
            
            tBoard = Array(tRows).fill(null).map(() => Array(tCols).fill(0));
            tScore = 0; tScoreEl.innerText = 0; tGameOver = false; tIsAnimating = false;
            
            tNextPiece = createPiece();
            spawnPiece();
            
            if(tInterval) clearInterval(tInterval);
            tInterval = setInterval(updateTetris, tSpeed);
            drawTetris();
        }

        function stopTetris() { clearInterval(tInterval); }

        function createPiece() {
            const id = Math.floor(Math.random() * SHAPES.length);
            return {
                matrix: JSON.parse(JSON.stringify(SHAPES[id])),
                color: COLORS[id],
                x: 0, y: 0
            };
        }

        function spawnPiece() {
            tPiece = tNextPiece;
            tNextPiece = createPiece();
            tPiece.x = Math.floor((tCols - tPiece.matrix[0].length) / 2);
            tPiece.y = 0;
            drawNextPiece();
            if (collide(tBoard, tPiece)) {
                tGameOver = true;
                stopTetris();
                alert("Game Over Tetris ! Score : " + tScore);
                backToHub();
            }
        }

        function drawTetrisBlock(ctx, x, y, color, size) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, size, size);
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(255,255,255,0.5)'; 
            ctx.beginPath(); ctx.moveTo(x, y+size); ctx.lineTo(x, y); ctx.lineTo(x+size, y); ctx.stroke();
            ctx.strokeStyle = 'rgba(0,0,0,0.4)'; 
            ctx.beginPath(); ctx.moveTo(x+size, y); ctx.lineTo(x+size, y+size); ctx.lineTo(x, y+size); ctx.stroke();
        }

        function drawNextPiece() {
            nCtx.fillStyle = '#000'; nCtx.fillRect(0,0,80,80);
            const m = tNextPiece.matrix;
            const size = 15;
            const offX = (80 - m[0].length * size)/2;
            const offY = (80 - m.length * size)/2;
            for(let y=0; y<m.length; y++) {
                for(let x=0; x<m[y].length; x++) {
                    if(m[y][x]) drawTetrisBlock(nCtx, offX + x*size, offY + y*size, tNextPiece.color, size);
                }
            }
        }

        function updateTetris() {
            if(tGameOver || tIsAnimating) return;
            tPiece.y++;
            if (collide(tBoard, tPiece)) {
                tPiece.y--;
                merge(tBoard, tPiece);
                arenaSweep();
                if(!tIsAnimating) spawnPiece(); 
            }
            drawTetris();
        }

        function drawTetris() {
            tCtx.fillStyle = '#000'; tCtx.fillRect(0, 0, tCanvas.width, tCanvas.height);
            for(let y=0; y<tRows; y++) for(let x=0; x<tCols; x++) if(tBoard[y][x]) {
                drawTetrisBlock(tCtx, x*tBlockSize, y*tBlockSize, tBoard[y][x], tBlockSize);
            }
            if(tPiece) {
                for(let y=0; y<tPiece.matrix.length; y++) for(let x=0; x<tPiece.matrix[y].length; x++) if(tPiece.matrix[y][x]) {
                    drawTetrisBlock(tCtx, (tPiece.x + x)*tBlockSize, (tPiece.y + y)*tBlockSize, tPiece.color, tBlockSize);
                }
            }
        }

        function collide(board, piece) {
            const m = piece.matrix;
            for(let y=0; y<m.length; y++) for(let x=0; x<m[y].length; x++) if(m[y][x] !== 0) if(!board[y + piece.y] || board[y + piece.y][x + piece.x] !== 0) return true;
            return false;
        }

        function merge(board, piece) {
            piece.matrix.forEach((row, y) => { row.forEach((value, x) => { if (value !== 0) board[y + piece.y][x + piece.x] = piece.color; }); });
        }

        function arenaSweep() {
            let linesToClear = [];
            for(let y=tRows-1; y>=0; y--) {
                let full = true;
                for(let x=0; x<tCols; x++) if(tBoard[y][x] === 0) { full = false; break; }
                if(full) linesToClear.push(y);
            }
            if(linesToClear.length > 0) {
                tIsAnimating = true;
                let flashCount = 0;
                let flashInterval = setInterval(() => {
                    tCtx.fillStyle = (flashCount % 2 === 0) ? 'white' : 'rgba(255,255,255,0.5)';
                    for(let row of linesToClear) {
                        tCtx.fillRect(0, row * tBlockSize, tCanvas.width, tBlockSize);
                    }
                    flashCount++;
                    if(flashCount > 3) {
                        clearInterval(flashInterval);
                        for(let row of linesToClear) {
                            tBoard.splice(row, 1);
                            tBoard.unshift(Array(tCols).fill(0));
                        }
                        let newBoard = tBoard.filter(row => !row.every(cell => cell !== 0));
                        while(newBoard.length < tRows) newBoard.unshift(Array(tCols).fill(0));
                        tBoard = newBoard;
                        tScore += linesToClear.length * 100 * linesToClear.length;
                        tScoreEl.innerText = tScore;
                        tIsAnimating = false;
                        spawnPiece();
                        drawTetris();
                    }
                }, 80);
            }
        }

        function rotate(matrix) {
            for(let y=0; y<matrix.length; ++y) for(let x=0; x<y; ++x) [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
            matrix.forEach(row => row.reverse());
        }

        function playerRotate() {
            const pos = tPiece.x; rotate(tPiece.matrix);
            if(collide(tBoard, tPiece)) { tPiece.x = pos; rotate(tPiece.matrix); rotate(tPiece.matrix); rotate(tPiece.matrix); }
        }

        // ============================
        // === GLOBAL INPUTS ===
        // ============================
        document.addEventListener('keydown', event => {
            const k = event.keyCode;
            
            // GLOBAL KEYS
            if([37,38,39,40,32].includes(k) && currentGameMode) event.preventDefault();

            // PONG
            if(currentGameMode === 'pong') {
                const step = 20;
                if(k === 38) pPad1.y -= step; // UP
                if(k === 40) pPad1.y += step; // DOWN
                if(pPad1.y < 0) pPad1.y = 0;
                if(pPad1.y + pPad1.h > pCanvas.height) pPad1.y = pCanvas.height - pPad1.h;
            }

            // TETRIS
            if(currentGameMode === 'tetris' && !tGameOver && !tIsAnimating) {
                if(k === 37) { tPiece.x--; if(collide(tBoard, tPiece)) tPiece.x++; } 
                else if(k === 39) { tPiece.x++; if(collide(tBoard, tPiece)) tPiece.x--; } 
                else if(k === 40) { tPiece.y++; if(collide(tBoard, tPiece)) tPiece.y--; } 
                else if(k === 38 || k===32) { playerRotate(); }
                drawTetris();
            }

            // SNAKE
            if(currentGameMode === 'snake') {
                if(k==37&&sVelX!=1){sVelX=-1;sVelY=0;} 
                if(k==38&&sVelY!=1){sVelX=0;sVelY=-1;} 
                if(k==39&&sVelX!=-1){sVelX=1;sVelY=0;} 
                if(k==40&&sVelY!=-1){sVelX=0;sVelY=1;}
            }

            // TRON
            if(currentGameMode === 'tron') {
                // P1 (ZQSD - WASD)
                if(k==81 || k==65) { if(tronP1.dx!==1) tP1NextDir = {dx:-1, dy:0}; } // Q/A
                if(k==90 || k==87) { if(tronP1.dy!==1) tP1NextDir = {dx:0, dy:-1}; } // Z/W
                if(k==68) { if(tronP1.dx!==-1) tP1NextDir = {dx:1, dy:0}; }  // D
                if(k==83) { if(tronP1.dy!==-1) tP1NextDir = {dx:0, dy:1}; }  // S

                // P2 (Fl√®ches) - seulement si pas CPU
                if(!tronIsCPU) {
                    if(k==37) { if(tronP2.dx!==1) tP2NextDir = {dx:-1, dy:0}; } 
                    if(k==38) { if(tronP2.dy!==1) tP2NextDir = {dx:0, dy:-1}; } 
                    if(k==39) { if(tronP2.dx!==-1) tP2NextDir = {dx:1, dy:0}; } 
                    if(k==40) { if(tronP2.dy!==-1) tP2NextDir = {dx:0, dy:1}; }
                }
            }

            // FLAPPY
            if(currentGameMode === 'flappy') {
                if(k === 32) jumpFlappy(); // Space
                if(k === 13 && fGameState === 'over') startFlappy(); // Enter to restart
            }
        });
        
        tCanvas.addEventListener('click', (e) => {
            if(currentGameMode === 'tetris' && !tGameOver && !tIsAnimating) { e.preventDefault(); playerRotate(); drawTetris(); }
        });

        document.getElementById('flappyCanvas').addEventListener('click', (e) => {
            if(currentGameMode === 'flappy') { e.preventDefault(); jumpFlappy(); }
        });

        // === SNAKE LOGIC ===
        const sCanvas=document.getElementById("snakeCanvas"), sCtx=sCanvas.getContext("2d"), sScoreEl=document.getElementById("snakeScoreVal");
        let sInterval, sTileCount=20, sGridSize=20, sHeadX=10, sHeadY=10, sAppleX=5, sAppleY=5, sVelX=0, sVelY=0, sTrail=[], sTail=5, sScore=0, sWallsSolid=false;
        function startSnakeGame(speed, mapSize) { sWallsSolid=document.getElementById('snakeWallCheck').checked; document.getElementById('snakeMenu').style.display='none'; sCanvas.style.display='block'; document.getElementById('snakeScoreBoard').style.display='block'; currentGameMode='snake'; sTileCount=mapSize; sGridSize=sCanvas.width/sTileCount; resetSnakeVars(); sInterval=setInterval(loopSnake, speed); }
        function stopSnake() { clearInterval(sInterval); }
        function resetSnakeVars() { sHeadX=Math.floor(sTileCount/2); sHeadY=Math.floor(sTileCount/2); sTrail=[]; sTail=5; sScore=0; sVelX=0; sVelY=0; sScoreEl.innerText=sScore; placeSnakeApple(); }
        function loopSnake() { sHeadX+=sVelX; sHeadY+=sVelY; if(sWallsSolid){if(sHeadX<0||sHeadX>=sTileCount||sHeadY<0||sHeadY>=sTileCount){snakeGameOver();return;}}else{if(sHeadX<0)sHeadX=sTileCount-1;if(sHeadX>=sTileCount)sHeadX=0;if(sHeadY<0)sHeadY=sTileCount-1;if(sHeadY>=sTileCount)sHeadY=0;} sCtx.fillStyle="black"; sCtx.fillRect(0,0,sCanvas.width,sCanvas.height); sCtx.fillStyle="red"; sCtx.fillRect(sAppleX*sGridSize,sAppleY*sGridSize,sGridSize-1,sGridSize-1); sCtx.fillStyle="lime"; for(let i=0;i<sTrail.length;i++){sCtx.fillRect(sTrail[i].x*sGridSize,sTrail[i].y*sGridSize,sGridSize-1,sGridSize-1);if(sTrail[i].x===sHeadX&&sTrail[i].y===sHeadY&&sTail>5){snakeGameOver();return;}} sTrail.push({x:sHeadX,y:sHeadY}); while(sTrail.length>sTail)sTrail.shift(); if(sAppleX===sHeadX&&sAppleY===sHeadY){sTail++;sScore++;sScoreEl.innerText=sScore;placeSnakeApple();} }
        function placeSnakeApple() { sAppleX=Math.floor(Math.random()*sTileCount); sAppleY=Math.floor(Math.random()*sTileCount); }
        function snakeGameOver() { stopSnake(); alert("Perdu ! Score Snake : " + sScore); document.getElementById('snakeMenu').style.display='block'; sCanvas.style.display='none'; document.getElementById('snakeScoreBoard').style.display='none'; }

        // === MINESWEEPER LOGIC ===
        const mGrid = document.getElementById('grid'), mFlagsEl = document.getElementById('flagsLeft'), mTimerEl = document.getElementById('mineTimer');
        let mWidth = 10, mBombs = 10, mSquares = [], mGameOver = false, mFlags = 0, mSec = 0, mTimerId;
        function startMineGame(w, b) { mWidth = w; mBombs = b; document.getElementById('mineMenu').style.display = 'none'; document.getElementById('mineGameContainer').style.display = 'flex'; currentGameMode = 'mine'; mGrid.style.gridTemplateColumns = `repeat(${mWidth}, 30px)`; document.getElementById('mineHeader').style.width = `${(mWidth * 32) + 20}px`; initMineBoard(); }
        function stopMine() { clearInterval(mTimerId); }
        function initMineBoard() { stopMine(); mGrid.innerHTML = ''; mSquares = []; mGameOver = false; mFlags = 0; mSec = 0; mTimerEl.innerHTML = '0'; mFlagsEl.innerHTML = mBombs; mTimerId = setInterval(() => { if(!mGameOver) { mSec++; mTimerEl.innerHTML = mSec; } }, 1000); createMineGrid(); }
        function createMineGrid() { const bombsArray = Array(mBombs).fill('bomb'); const emptyArray = Array(mWidth * mWidth - mBombs).fill('valid'); const gameArray = emptyArray.concat(bombsArray); for (let i = gameArray.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [gameArray[i], gameArray[j]] = [gameArray[j], gameArray[i]]; } for(let i = 0; i < mWidth * mWidth; i++) { const square = document.createElement('div'); square.setAttribute('id', i); square.classList.add('cell'); square.dataset.type = gameArray[i]; square.addEventListener('click', () => clickMine(square)); square.oncontextmenu = (e) => { e.preventDefault(); addMineFlag(square); }; mGrid.appendChild(square); mSquares.push(square); } for (let i = 0; i < mSquares.length; i++) { let total = 0; const isLeft = (i % mWidth === 0); const isRight = (i % mWidth === mWidth -1); if (mSquares[i].dataset.type === 'valid') { if (i > 0 && !isLeft && mSquares[i-1].dataset.type === 'bomb') total++; if (i > mWidth-1 && !isRight && mSquares[i+1-mWidth].dataset.type === 'bomb') total++; if (i > mWidth && mSquares[i-mWidth].dataset.type === 'bomb') total++; if (i > mWidth+1 && !isLeft && mSquares[i-1-mWidth].dataset.type === 'bomb') total++; if (i < mWidth*mWidth-2 && !isRight && mSquares[i+1].dataset.type === 'bomb') total++; if (i < mWidth*mWidth-mWidth && !isLeft && mSquares[i-1+mWidth].dataset.type === 'bomb') total++; if (i < mWidth*mWidth-mWidth-2 && !isRight && mSquares[i+1+mWidth].dataset.type === 'bomb') total++; if (i < mWidth*mWidth-mWidth-1 && mSquares[i+mWidth].dataset.type === 'bomb') total++; mSquares[i].setAttribute('data', total); } } }
        function addMineFlag(square) { if (mGameOver || square.classList.contains('revealed')) return; if (!square.classList.contains('flag')) { if (mFlags < mBombs) { square.classList.add('flag'); square.innerHTML = 'üö©'; mFlags++; checkMineWin(); } } else { square.classList.remove('flag'); square.innerHTML = ''; mFlags--; } mFlagsEl.innerHTML = mBombs - mFlags; }
        function clickMine(square) { if (mGameOver || square.classList.contains('revealed') || square.classList.contains('flag')) return; if (square.dataset.type === 'bomb') { mGameOver = true; stopMine(); mSquares.forEach(sq => { if (sq.dataset.type === 'bomb') { sq.innerHTML = 'üí£'; sq.classList.add('bomb'); } }); square.classList.add('bomb'); } else { let total = square.getAttribute('data'); if (total != 0) { square.classList.add('revealed'); square.innerHTML = total; square.classList.add('c'+total); } else { checkMineSquare(square, square.id); } } square.classList.add('revealed'); checkMineWin(); }
        function checkMineSquare(square, currentId) { const isLeft = (currentId % mWidth === 0); const isRight = (currentId % mWidth === mWidth -1); setTimeout(() => { const newId = parseInt(currentId); const neighbors = []; if (newId > 0 && !isLeft) neighbors.push(newId - 1); if (newId > mWidth - 1 && !isRight) neighbors.push(newId + 1 - mWidth); if (newId >= mWidth) neighbors.push(newId - mWidth); if (newId > mWidth && !isLeft) neighbors.push(newId - 1 - mWidth); if (newId < mWidth * mWidth - 1 && !isRight) neighbors.push(newId + 1); if (newId < mWidth * mWidth - mWidth && !isLeft) neighbors.push(newId - 1 + mWidth); if (newId < mWidth * mWidth - mWidth - 1 && !isRight) neighbors.push(newId + 1 + mWidth); if (newId < mWidth * mWidth - mWidth) neighbors.push(newId + mWidth); neighbors.forEach(nId => { const nSq = document.getElementById(nId); if (nSq && !nSq.classList.contains('revealed') && !nSq.classList.contains('flag')) clickMine(nSq); }); }, 10); }
        function checkMineWin() { let rev = 0; mSquares.forEach(sq => { if(sq.classList.contains('revealed')) rev++; }); if (rev === (mWidth * mWidth - mBombs)) { mGameOver = true; stopMine(); alert("GAGN√â D√âMINEUR ! Temps : " + mSec + "s"); } }

        // === LOGIQUE G√âN√âRIQUE JEUX DE GRILLE (TTT & P4) ===
        function checkGenericWin(board, rows, cols, winLen, player) {
            for(let r=0; r<rows; r++) { for(let c=0; c<=cols-winLen; c++) { let win = true; for(let k=0; k<winLen; k++) if(board[r][c+k] !== player) win = false; if(win) return { type: 'horiz', r: r, c: c, len: winLen }; } }
            for(let c=0; c<cols; c++) { for(let r=0; r<=rows-winLen; r++) { let win = true; for(let k=0; k<winLen; k++) if(board[r+k][c] !== player) win = false; if(win) return { type: 'vert', r: r, c: c, len: winLen }; } }
            for(let r=0; r<=rows-winLen; r++) { for(let c=0; c<=cols-winLen; c++) { let win = true; for(let k=0; k<winLen; k++) if(board[r+k][c+k] !== player) win = false; if(win) return { type: 'diagDR', r: r, c: c, len: winLen }; } }
            for(let r=winLen-1; r<rows; r++) { for(let c=0; c<=cols-winLen; c++) { let win = true; for(let k=0; k<winLen; k++) if(board[r-k][c+k] !== player) win = false; if(win) return { type: 'diagUR', r: r, c: c, len: winLen }; } }
            return null;
        }

        function drawGenericLine(winInfo, container, cellSize, gap) {
            const line = document.createElement('div'); line.className = 'winning-line'; line.style.height = '6px';
            const startX = 10 + (winInfo.c * (cellSize + gap)) + (cellSize / 2);
            const startY = 10 + (winInfo.r * (cellSize + gap)) + (cellSize / 2);
            let endR = winInfo.r, endC = winInfo.c;
            if(winInfo.type === 'horiz') endC += (winInfo.len - 1);
            if(winInfo.type === 'vert') endR += (winInfo.len - 1);
            if(winInfo.type === 'diagDR') { endR += (winInfo.len - 1); endC += (winInfo.len - 1); }
            if(winInfo.type === 'diagUR') { endR -= (winInfo.len - 1); endC += (winInfo.len - 1); }
            const endX = 10 + (endC * (cellSize + gap)) + (cellSize / 2);
            const endY = 10 + (endR * (cellSize + gap)) + (cellSize / 2);
            const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
            const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;
            line.style.width = length + 'px'; line.style.left = startX + 'px'; line.style.top = (startY - 3) + 'px';
            line.style.transform = `rotate(${angle}deg)`; line.style.display = 'block';
            container.appendChild(line);
        }

        // === TIC TAC TOE LOGIC ===
        const tttGrid = document.getElementById('tttGrid'), tttStatus = document.getElementById('tttStatus'), scoreXEl = document.getElementById('scoreX'), scoreOEl = document.getElementById('scoreO');
        let tttBoard = [], tttCurrentPlayer = 'X', tttGameActive = true, tttMode = 'pvp', tttScoreX = 0, tttScoreO = 0;
        function startTTT(mode) { 
            tttMode = mode; if(mode !== 'pvp') { tttSize=3; tttWinLen=3; }
            document.getElementById('tttMenu').style.display = 'none'; document.getElementById('tttGameContainer').style.display = 'flex'; currentGameMode = 'tictactoe'; tttScoreX = 0; tttScoreO = 0; updateTTTScoreBoard(); 
            tttGrid.style.gridTemplateColumns = `repeat(${tttSize}, 60px)`; tttGrid.style.gridTemplateRows = `repeat(${tttSize}, 60px)`; resetTTT(false); 
        }
        function backToTTTMenu() { document.getElementById('tttGameContainer').style.display = 'none'; document.getElementById('tttMenu').style.display = 'block'; }
        function triggerResetTTT() { if(!tttGameActive && checkBoardEmpty(tttBoard)) return; document.querySelectorAll('.ttt-cell').forEach(c => c.classList.add('disappear')); const line = tttGrid.querySelector('.winning-line'); if(line) line.remove(); setTimeout(() => { resetTTT(true); }, 300); }
        function resetTTT(animate) { tttBoard = Array(tttSize).fill(null).map(() => Array(tttSize).fill('')); tttCurrentPlayer = tttStart; tttGameActive = true; tttStatus.innerText = "Tour de : " + tttCurrentPlayer; renderTTT(); if (tttMode.startsWith('cpu') && tttCurrentPlayer === 'O') setTimeout(cpuMoveTTT, 600); }
        function updateTTTScoreBoard() { scoreXEl.innerText = tttScoreX; scoreOEl.innerText = tttScoreO; }
        function renderTTT() { tttGrid.innerHTML = ''; for(let r=0; r<tttSize; r++){ for(let c=0; c<tttSize; c++){ const cellDiv = document.createElement('div'); cellDiv.classList.add('ttt-cell'); if(tttBoard[r][c] === 'X') cellDiv.classList.add('x'); if(tttBoard[r][c] === 'O') cellDiv.classList.add('o'); cellDiv.innerText = tttBoard[r][c]; cellDiv.addEventListener('click', () => handleTTTClick(r, c)); tttGrid.appendChild(cellDiv); } } }
        function handleTTTClick(r, c) { if (tttBoard[r][c] !== '' || !tttGameActive) return; tttBoard[r][c] = tttCurrentPlayer; renderTTT(); const win = checkGenericWin(tttBoard, tttSize, tttSize, tttWinLen, tttCurrentPlayer); if(win) { tttStatus.innerText = `Le joueur ${tttCurrentPlayer} a gagn√© !`; tttGameActive = false; drawGenericLine(win, tttGrid, 60, 5); if(tttCurrentPlayer === 'X') tttScoreX++; else tttScoreO++; updateTTTScoreBoard(); return; } if (checkBoardFull(tttBoard)) { tttStatus.innerText = "Match Nul !"; tttGameActive = false; return; } tttCurrentPlayer = tttCurrentPlayer === 'X' ? 'O' : 'X'; tttStatus.innerText = "Tour de : " + tttCurrentPlayer; if (tttGameActive && tttMode.startsWith('cpu') && tttCurrentPlayer === 'O') { setTimeout(cpuMoveTTT, 500); } }
        function checkBoardEmpty(b) { for(let r=0;r<b.length;r++)for(let c=0;c<b[0].length;c++)if(b[r][c]!=='')return false; return true; }
        function checkBoardFull(b) { for(let r=0;r<b.length;r++)for(let c=0;c<b[0].length;c++)if(b[r][c]==='')return false; return true; }
        function cpuMoveTTT() { if(!tttGameActive) return; let move = findBestMoveGeneric(tttBoard, tttSize, tttSize, tttWinLen, 'O', 'X'); tttBoard[move.r][move.c] = 'O'; renderTTT(); const win = checkGenericWin(tttBoard, tttSize, tttSize, tttWinLen, 'O'); if(win) { tttStatus.innerText = "O a gagn√© !"; tttGameActive = false; tttScoreO++; updateTTTScoreBoard(); drawGenericLine(win, tttGrid, 60, 5); return; } if(checkBoardFull(tttBoard)) { tttStatus.innerText = "Match Nul"; tttGameActive = false; return; } tttCurrentPlayer = 'X'; tttStatus.innerText = "Tour de : X"; }
        function findBestMoveGeneric(board, rows, cols, winLen, me, opp) { for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) { if(board[r][c] === '') { board[r][c] = me; if(checkGenericWin(board, rows, cols, winLen, me)) { board[r][c] = ''; return {r,c}; } board[r][c] = ''; } } for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) { if(board[r][c] === '') { board[r][c] = opp; if(checkGenericWin(board, rows, cols, winLen, opp)) { board[r][c] = ''; return {r,c}; } board[r][c] = ''; } } let available = []; for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) if(board[r][c]==='') available.push({r,c}); return available[Math.floor(Math.random()*available.length)]; }

        // === CONNECT 4 LOGIC ===
        const c4Grid = document.getElementById('c4Grid'), c4Status = document.getElementById('c4Status'), c4ScoreRedEl = document.getElementById('c4ScoreRed'), c4ScoreYellowEl = document.getElementById('c4ScoreYellow');
        let c4Board = [], c4Player = 'R', c4Active = true, c4Mode = 'pvp', c4ScoreR = 0, c4ScoreY = 0;
        function startC4(mode) { c4Mode = mode; if(mode !== 'pvp') { c4Rows=6; c4Cols=7; c4WinLen=4; } document.getElementById('c4Menu').style.display = 'none'; document.getElementById('c4GameContainer').style.display = 'flex'; currentGameMode = 'connect4'; c4ScoreR = 0; c4ScoreY = 0; updateC4Score(); c4Grid.style.gridTemplateColumns = `repeat(${c4Cols}, 50px)`; c4Grid.style.gridTemplateRows = `repeat(${c4Rows}, 50px)`; resetC4(); }
        function backToC4Menu() { document.getElementById('c4GameContainer').style.display = 'none'; document.getElementById('c4Menu').style.display = 'block'; }
        function triggerResetC4() { if(!c4Active && checkBoardFullC4(c4Board)) return; document.querySelectorAll('.c4-cell').forEach(c => c.classList.add('disappear')); const line = c4Grid.querySelector('.winning-line'); if(line) line.remove(); setTimeout(resetC4, 300); }
        function resetC4() { c4Board = Array(c4Rows).fill(null).map(() => Array(c4Cols).fill(null)); c4Player = c4Start; c4Active = true; c4Status.innerText = "Tour de : " + (c4Player === 'R' ? "ROUGE" : "JAUNE"); c4Status.style.color = (c4Player === 'R' ? "#e74c3c" : "#f1c40f"); renderC4(); if (c4Mode.startsWith('cpu') && c4Player === 'Y') setTimeout(c4Cpu, 600); }
        function updateC4Score() { c4ScoreRedEl.innerText = c4ScoreR; c4ScoreYellowEl.innerText = c4ScoreY; }
        function renderC4() { c4Grid.innerHTML = ''; for (let r = 0; r < c4Rows; r++) { for (let c = 0; c < c4Cols; c++) { const cell = document.createElement('div'); cell.classList.add('c4-cell'); cell.dataset.col = c; if (c4Board[r][c] === 'R') cell.classList.add('red'); if (c4Board[r][c] === 'Y') cell.classList.add('yellow'); cell.addEventListener('click', () => handleC4Click(c)); c4Grid.appendChild(cell); } } }
        function handleC4Click(col) { if (!c4Active) return; const r = getLowRow(c4Board, col); if (r === -1) return; c4Board[r][col] = c4Player; renderC4(); const win = checkGenericWin(c4Board, c4Rows, c4Cols, c4WinLen, c4Player); if(win) { c4Status.innerText = (c4Player === 'R' ? "ROUGE" : "JAUNE") + " GAGNE !"; c4Active = false; if(c4Player === 'R') c4ScoreR++; else c4ScoreY++; updateC4Score(); drawGenericLine(win, c4Grid, 50, 8); return; } if (checkBoardFullC4(c4Board)) { c4Status.innerText = "MATCH NUL"; c4Status.style.color = "#fff"; c4Active = false; return; } c4Player = c4Player === 'R' ? 'Y' : 'R'; c4Status.innerText = "Tour de : " + (c4Player === 'R' ? "ROUGE" : "JAUNE"); c4Status.style.color = c4Player === 'R' ? "#e74c3c" : "#f1c40f"; if (c4Active && c4Mode.startsWith('cpu') && c4Player === 'Y') setTimeout(c4Cpu, 500); }
        function getLowRow(b, c) { for (let r = c4Rows - 1; r >= 0; r--) if (b[r][c] === null) return r; return -1; }
        function checkBoardFullC4(b) { for (let c = 0; c < c4Cols; c++) if (b[0][c] === null) return false; return true; }
        function c4Cpu() { if (!c4Active) return; let col = -1; for(let c=0; c<c4Cols; c++) { let r = getLowRow(c4Board, c); if(r!==-1) { c4Board[r][c] = 'Y'; if(checkGenericWin(c4Board, c4Rows, c4Cols, c4WinLen, 'Y')) { c4Board[r][c] = null; col=c; break; } c4Board[r][c] = null; } } if(col === -1) { for(let c=0; c<c4Cols; c++) { let r = getLowRow(c4Board, c); if(r!==-1) { c4Board[r][c] = 'R'; if(checkGenericWin(c4Board, c4Rows, c4Cols, c4WinLen, 'R')) { c4Board[r][c] = null; col=c; break; } c4Board[r][c] = null; } } } if(col === -1) { let valid = []; for(let c=0;c<c4Cols;c++) if(c4Board[0][c]===null) valid.push(c); col = valid[Math.floor(Math.random()*valid.length)]; } const row = getLowRow(c4Board, col); c4Board[row][col] = 'Y'; renderC4(); const win = checkGenericWin(c4Board, c4Rows, c4Cols, c4WinLen, 'Y'); if (win) { c4Status.innerText = "JAUNE GAGNE !"; c4Active = false; c4ScoreY++; updateC4Score(); drawGenericLine(win, c4Grid, 50, 8); return; } if (checkBoardFullC4(c4Board)) { c4Status.innerText = "MATCH NUL"; c4Active = false; return; } c4Player = 'R'; c4Status.innerText = "Tour de : ROUGE"; c4Status.style.color = "#e74c3c"; }
    </script>
</body>
</html>
